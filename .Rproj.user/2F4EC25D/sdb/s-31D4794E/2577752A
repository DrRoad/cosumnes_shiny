{
    "collab_server" : "",
    "contents" : "shinyServer(function(input, output, session){\n\nobserveEvent(input$location, {\n    x <- input$location\n\tif(!is.null(x) && x!=\"\"){\n        sink(\"locationLog.txt\", append=TRUE, split=FALSE)\n        cat(paste0(x, \"\\n\"))\n        sink()\n    }\n})\n\n# leaflet output of wells\noutput$Map <- renderLeaflet({\n\tleaflet() %>% addProviderTiles(providers$Esri.WorldImagery) %>% setView(lng=-121.378, lat=38.30139, zoom=13) %>%\n\t\taddCircleMarkers(data=cs_coords, \n\t\t                 stroke=FALSE, \n\t\t                 fillOpacity=.6, \n\t\t                 color= \"magenta\",\n\t\t                 radius = 5,\n\t\t                 layerId = ~Location, \n\t\t                 label = ~hover_text,\n\t\t                 labelOptions = labelOptions(\n\t\t                   offset = c(-50,-105),\n\t\t                   #direction='bottom',\n\t\t                   textOnly = T,\n\t\t                   style=list(\n\t\t                     'background'='rgba(255,255,255,0.95)',\n\t\t                     'border-color' = 'rgba(0,0,0,1)',\n\t\t                     'border-radius' = '3px',\n\t\t                     'border-style' = 'solid',\n\t\t                     'border-width' = '4px'))\n\t\t                 )\n})\n\nobserveEvent(input$Map_marker_click, {\n    p <- input$Map_marker_click\n\tif(p$id==\"Selected\"){\n\t\tleafletProxy(\"Map\") %>% removeMarker(layerId=\"Selected\")\n\t} else {\n\t\tleafletProxy(\"Map\") %>% setView(lng=p$lng, lat=p$lat, input$Map_zoom) %>% addCircleMarkers(p$lng, p$lat, radius=10, color=\"black\", fillColor=\"orange\", fillOpacity=1, opacity=1, stroke=TRUE, layerId=\"Selected\")\n\t}\n})\n\nobserveEvent(input$Map_marker_click, {\n\tp <- input$Map_marker_click\n\tif(!is.null(p$id)){\n\t\tif(is.null(input$location)) updateSelectInput(session, \"location\", selected=p$id)\n\t\tif(!is.null(input$location) && input$location!=p$id) updateSelectInput(session, \"location\", selected=p$id)\n\t}\n})\n\n# when a location is chosen in the drop down menu, change the map popup\nobserveEvent(input$location, {\n\tp <- input$Map_marker_click\n\tp2 <- cs_coords %>% filter(Location==input$location)\n\tif(nrow(p2)==0){\n\t\tleafletProxy(\"Map\") %>% removeMarker(layerId=\"Selected\")\n\t} else if(is.null(p$id) || input$location!=p$id){\n\t\tleafletProxy(\"Map\") %>% setView(lng=p2$lng, lat=p2$lat, input$Map_zoom) %>% addCircleMarkers(p2$lng, p2$lat, radius=10, color=\"black\", fillColor=\"orange\", fillOpacity=1, opacity=1, stroke=TRUE, layerId=\"Selected\")\n\t}\n})\n\n\n\n# when the location changes, so does the data for the plot\nlocation <- reactive({ \n  well_dat_daily %>% gather(wells, value, -Date) %>% \n    filter(wells == input$location)\n})\n\n\nlocation_units <- reactive({\n  temp <- location()\n  if(input$units == \"feet\") return(cbind.data.frame(Date = temp[,1], value = (temp[,3]) * 3.28084)) else return(temp) \n})\n  \n\n\n# individual well plot\noutput$Chart1 <- renderPlotly({\n  if(!length(input$location) || input$location==\"\") return(plotly()) # blank until a location is selected\n  \n  # plot\n  location_units() %>% \n    plot_ly(x = ~Date) %>%\n    add_lines(y = ~value, name = input$location) %>% \n    layout(\n      title = FALSE,\n      # title = paste0(\"Monitoring Well ID: \", input$location),\n      xaxis = list(\n        rangeselector = list(\n          buttons = list(\n            list(\n              count = 3,\n              label = \"3 mo\",\n              step = \"month\",\n              stepmode = \"backward\"),\n            list(\n              count = 6,\n              label = \"6 mo\",\n              step = \"month\",\n              stepmode = \"backward\"),\n            list(\n              count = 1,\n              label = \"1 yr\",\n              step = \"year\",\n              stepmode = \"backward\"),\n            list(\n              count = 1,\n              label = \"YTD\",\n              step = \"year\",\n              stepmode = \"todate\"),\n            list(step = \"all\"))),\n        \n        rangeslider = list(type = \"date\")),\n      \n      yaxis = list(title = paste0(\"Level (\", input$units, \")\"))) %>% \n    config(displayModeBar = FALSE) %>% \n    add_annotations(\n      yref=\"paper\", \n      xref=\"paper\", \n      y=1.15, \n      x=1, \n      text = paste0(input$location, \" Hydrograph\"), \n      showarrow=F, \n      font=list(size=17)\n    )\n})\n\n\n# map for all wells\noutput$network <- renderPlotly({\n  # gather data and get geom_smooth line from it\n  temp <- NA\n  ifelse(input$units_2 == \"meters\", \n         temp <- well_dat_daily, \n         temp <- cbind.data.frame(Date = well_dat_daily[,1], (well_dat_daily[,-1]) * 3.28084))\n  \n  temp %>% \n    gather(wells, level, -Date) %>% \n    qplot(Date, level, data = .) + stat_smooth() -> p\n  \n  # get geom_smooth coords \n  ggplot_build(p)$data[[2]] %>% select(x,y,ymin,ymax) -> smooth\n  \n  #smooth$x <- as.Date(as.POSIXct(smooth$x, origin=\"1970-01-01\"))\n  smooth$x <- anytime(smooth$x)\n  \n  # plot \n  plot_ly(temp, x = ~Date) %>%\n    add_lines(y = ~MW2, name = \"MW2\", color= I(\"gray5\")) %>%\n    add_lines(y = ~MW9, name = \"MW9\", color= I(\"gray10\")) %>%\n    add_lines(y = ~MW11, name = \"MW11\", color= I(\"gray15\")) %>%\n    add_lines(y = ~MW20, name = \"MW20\", color= I(\"gray20\")) %>%\n    add_lines(y = ~OnetoAg, name = \"OnetoAg\", color= I(\"gray25\")) %>%\n    add_lines(y = ~MW19, name = \"MM19\", color= I(\"gray30\")) %>%\n    add_lines(y = ~MW23, name = \"MW23\", color= I(\"gray35\")) %>%\n    add_lines(y = ~MW22, name = \"MW22\", color= I(\"gray40\")) %>%\n    add_lines(y = ~MW7, name = \"MW7\", color= I(\"gray45\")) %>%\n    add_lines(y = ~MW5, name = \"MW5\", color= I(\"gray50\")) %>%\n    add_lines(y = ~MW3, name = \"MW3\", color= I(\"gray55\")) %>%\n    add_lines(y = ~MW17, name = \"MW17\", color= I(\"gray60\")) %>%\n    add_lines(y = ~MW13, name = \"MW13\", color= I(\"gray65\")) %>%\n    add_ribbons(data = smooth, x=~x, ymin=~ymin, ymax=~ymax, color = I(\"gray80\"), name = \"Confidence Interval\") %>% \n    add_lines(data = smooth, x=~x, y=~y, color = I(\"red\"), name = \"AVERAGE\") %>% \n    layout(\n      showlegend = FALSE,\n      title = FALSE, #\"Entire Monitoring Well Network\",\n      xaxis = list(\n        rangeselector = list(\n          buttons = list(\n            list(\n              count = 3,\n              label = \"3 mo\",\n              step = \"month\",\n              stepmode = \"backward\"),\n            list(\n              count = 6,\n              label = \"6 mo\",\n              step = \"month\",\n              stepmode = \"backward\"),\n            list(\n              count = 1,\n              label = \"1 yr\",\n              step = \"year\",\n              stepmode = \"backward\"),\n            list(\n              count = 1,\n              label = \"YTD\",\n              step = \"year\",\n              stepmode = \"todate\"),\n            list(step = \"all\"))),\n        \n        rangeslider = list(type = \"date\"),\n        range = c( input$date_range[1], input$date_range[2]) \n      ),\n        \n      yaxis = list(title = paste0(\"Level (\", input$units_2, \")\"))\n      \n    ) %>% \n    \n    config(displayModeBar = FALSE)\n \n})\n\n# Download All Data\noutput$download_all_data <- downloadHandler(\n  # This function returns a string which tells the client browser what name to use when saving the file.\n  filename = function() {\n    paste0(\"UC_Water_gw_observatory\", \".csv\")\n  },\n  \n  # This function should write data to a file given to it by the argument 'file'.\n  content = function(file) {\n    # Write to a file specified by the 'file' argument\n    write.table(well_dat_daily, file, sep = \",\", row.names = FALSE)\n  }\n)\n\n})",
    "created" : 1523401569155.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3161505795",
    "id" : "2577752A",
    "lastKnownWriteTime" : 1521671303,
    "last_content_update" : 1521671303,
    "path" : "~/GitHub/aws_gwob/server.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}